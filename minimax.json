{
  "MinimaxTree": {
    "prefix": "???minimax-tree",
    "body": [
      "import math",
      "",
      "class Node:",
      "    def __init__(self, value=None):",
      "        self.value = value",
      "        self.children = []",
      "        self.minmax_value = None",
      "",
      "class MinimaxAgent:",
      "    def __init__(self, depth):",
      "        self.depth = depth",
      "        ",
      "    def formulate_goal(self, node):",
      "        # in Minimax, the goal is to compute the minimax value for the root node",
      "        return \"Goal reached\" if node.minmax_value is not None else \"Searching\"",
      "        ",
      "    def act(self, node, environment):",
      "        goal_status = self.formulate_goal(node)",
      "        if goal_status == \"Goal reached\":",
      "            return f\"Minimax value for root node: {node.minmax_value}\"",
      "        else:",
      "            return environment.compute_minimax(node, self.depth)",
      "",
      "class Environment:",
      "    def __init__(self, tree):",
      "        self.tree = tree",
      "        self.computed_nodes = []",
      "        ",
      "    def get_percept(self, node):",
      "        return node",
      "        ",
      "    def compute_minimax(self, node, depth, maximizing_player=True):",
      "        if depth == 0 or not node.children:",
      "            self.computed_nodes.append(node.value)",
      "            return node.value",
      "            ",
      "        if maximizing_player:",
      "            value = -math.inf",
      "            for child in node.children:",
      "                child_value = self.compute_minimax(child, depth - 1, False)",
      "                value = max(value, child_value)",
      "            node.minmax_value = value",
      "            self.computed_nodes.append(node.value)",
      "            return value",
      "        else:",
      "            value = math.inf",
      "            for child in node.children:",
      "                child_value = self.compute_minimax(child, depth - 1, True)",
      "                value = min(value, child_value)",
      "            node.minmax_value = value",
      "            self.computed_nodes.append(node.value)",
      "            return value",
      "",
      "def run_agent(agent, environment, start_node):",
      "    percept = environment.get_percept(start_node)",
      "    agent.act(percept, environment)",
      "",
      "# Example usage:",
      "if __name__ == \"__main__\":",
      "    # sample tree",
      "    root = Node('A')",
      "    n1 = Node('B')",
      "    n2 = Node('C')",
      "    root.children = [n1, n2]",
      "    ",
      "    n3 = Node('D')",
      "    n4 = Node('E')",
      "    n5 = Node('F')",
      "    n6 = Node('G')",
      "    n1.children = [n3, n4]",
      "    n2.children = [n5, n6]",
      "    ",
      "    n7 = Node(2)",
      "    n8 = Node(3)",
      "    n9 = Node(5)",
      "    n10 = Node(9)",
      "    n3.children = [n7, n8]",
      "    n4.children = [n9, n10]",
      "    ",
      "    n11 = Node(0)",
      "    n12 = Node(1)",
      "    n13 = Node(7)",
      "    n14 = Node(5)",
      "    n5.children = [n11, n12]",
      "    n6.children = [n13, n14]",
      "",
      "    # define depth for Minimax",
      "    depth = 3",
      "    agent = MinimaxAgent(depth)",
      "    environment = Environment(root)",
      "",
      "    run_agent(agent, environment, root)",
      "    print(\"Computed Nodes:\", environment.computed_nodes)",
      "    print(\"Minimax values:\")",
      "    print(\"A:\", root.minmax_value)",
      "    print(\"B:\", n1.minmax_value)",
      "    print(\"C:\", n2.minmax_value)",
      "    print(\"D:\", n3.minmax_value)",
      "    print(\"E:\", n4.minmax_value)",
      "    print(\"F:\", n5.minmax_value)",
      "    print(\"G:\", n6.minmax_value)"
    ],
    "description": "Full Minimax tree code from lab06.py"
  },
  "AlphaBetaTree": {
    "prefix": "???alpha-beta-tree",
    "body": [
      "import math",
      "",
      "class Node:",
      "    def __init__(self, value=None):",
      "        self.value = value",
      "        self.children = []",
      "        self.minmax_value = None",
      "",
      "class MinimaxAgent:",
      "    def __init__(self, depth):",
      "        self.depth = depth",
      "        ",
      "    def formulate_goal(self, node):",
      "        return \"Goal reached\" if node.minmax_value is not None else \"Searching\"",
      "        ",
      "    def act(self, node, environment):",
      "        goal_status = self.formulate_goal(node)",
      "        if goal_status == \"Goal reached\":",
      "            return f\"Minimax value for root node: {node.minmax_value}\"",
      "        else:",
      "            return environment.alpha_beta_search(node, self.depth, -math.inf, math.inf, True)",
      "",
      "class Environment:",
      "    def __init__(self, tree):",
      "        self.tree = tree",
      "        self.computed_nodes = []",
      "        ",
      "    def get_percept(self, node):",
      "        return node",
      "        ",
      "    def alpha_beta_search(self, node, depth, alpha, beta, maximizing_player=True):",
      "        self.computed_nodes.append(node.value)",
      "        if depth == 0 or not node.children:",
      "            return node.value",
      "            ",
      "        if maximizing_player:",
      "            value = -math.inf",
      "            for child in node.children:",
      "                value = max(value, self.alpha_beta_search(child, depth - 1, alpha, beta, False))",
      "                alpha = max(alpha, value)",
      "                if beta <= alpha:",
      "                    print(\"Pruned node:\", child.value)",
      "                    break",
      "            node.minmax_value = value",
      "            return value",
      "        else:",
      "            value = math.inf",
      "            for child in node.children:",
      "                value = min(value, self.alpha_beta_search(child, depth - 1, alpha, beta, True))",
      "                beta = min(beta, value)",
      "                if beta <= alpha:",
      "                    print(\"Pruned node:\", child.value)",
      "                    break",
      "            node.minmax_value = value",
      "            return value",
      "",
      "def run_agent(agent, environment, start_node):",
      "    percept = environment.get_percept(start_node)",
      "    agent.act(percept, environment)",
      "",
      "# Example usage:",
      "if __name__ == \"__main__\":",
      "    # constructing the tree",
      "    root = Node('A')",
      "    n1 = Node('B')",
      "    n2 = Node('C')",
      "    root.children = [n1, n2]",
      "    ",
      "    n3 = Node('D')",
      "    n4 = Node('E')",
      "    n5 = Node('F')",
      "    n6 = Node('G')",
      "    n1.children = [n3, n4]",
      "    n2.children = [n5, n6]",
      "    ",
      "    n7 = Node(2)",
      "    n8 = Node(3)",
      "    n9 = Node(5)",
      "    n10 = Node(9)",
      "    n3.children = [n7, n8]",
      "    n4.children = [n9, n10]",
      "    ",
      "    n11 = Node(0)",
      "    n12 = Node(1)",
      "    n13 = Node(7)",
      "    n14 = Node(5)",
      "    n5.children = [n11, n12]",
      "    n6.children = [n13, n14]",
      "",
      "    # define depth for Alpha-Beta pruning",
      "    depth = 3",
      "    agent = MinimaxAgent(depth)",
      "    environment = Environment(root)",
      "",
      "    run_agent(agent, environment, root)",
      "    print(\"Computed Nodes:\", environment.computed_nodes)",
      "    print(\"Minimax values:\")",
      "    print(f\"A: {root.minmax_value}\")",
      "    print(f\"B: {n1.minmax_value}\")",
      "    print(f\"C: {n2.minmax_value}\")",
      "    print(f\"D: {n3.minmax_value}\")",
      "    print(f\"E: {n4.minmax_value}\")",
      "    print(f\"F: {n5.minmax_value}\")",
      "    print(f\"G: {n6.minmax_value}\")"
    ],
    "description": "Full Alpha-Beta tree code from lab06.py"
  },
  "TicTacToeMinimax": {
    "prefix": "???tictactoe-minimax",
    "body": [
      "class TicTacToe:",
      "    def __init__(self):",
      "        # Initialize empty 3x3 board",
      "        self.board = [[' ', ' ', ' '] for _ in range(3)]",
      "        self.ai_symbol = 'X'",
      "        self.player_symbol = 'O'",
      "    ",
      "    def print_board(self):",
      "        \"\"\"Display the current state of the board\"\"\"",
      "        for i in range(3):",
      "            print(\"|\".join(self.board[i]))",
      "            if i < 2:",
      "                print('-' * 5)",
      "        print()",
      "    ",
      "    def is_valid_move(self, row, col):",
      "        \"\"\"Check if the move is valid\"\"\"",
      "        if 0 <= row < 3 and 0 <= col < 3 and self.board[row][col] == ' ':",
      "            return True",
      "        return False",
      "    ",
      "    def make_move(self, row, col, symbol):",
      "        \"\"\"Place a symbol on the board\"\"\"",
      "        if self.is_valid_move(row, col):",
      "            self.board[row][col] = symbol",
      "            return True",
      "        return False",
      "    ",
      "    def check_winner(self):",
      "        \"\"\"Check if there's a winner or draw\"\"\"",
      "        # Check rows",
      "        for row in range(3):",
      "            if self.board[row][0] == self.board[row][1] == self.board[row][2] != ' ':",
      "                return self.board[row][0]",
      "        # Check columns",
      "        for col in range(3):",
      "            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':",
      "                return self.board[0][col]",
      "        # Check diagonals",
      "        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':",
      "            return self.board[0][0]",
      "        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':",
      "            return self.board[0][2]",
      "        # Check for draw",
      "        if all(self.board[i][j] != ' ' for i in range(3) for j in range(3)):",
      "            return 'Draw'",
      "        # Game still in progress",
      "        return None",
      "    ",
      "    def get_empty_cells(self):",
      "        \"\"\"Return a list of empty cells as (row, col) tuples\"\"\"",
      "        return [(i, j) for i in range(3) for j in range(3) if self.board[i][j] == ' ']",
      "    ",
      "    def minimax(self, depth, is_maximizing, alpha=float('-inf'), beta=float('inf')):",
      "        \"\"\"",
      "        Minimax algorithm with Alpha-Beta pruning",
      "        Returns the best score and move (row, col)",
      "        \"\"\"",
      "        # Check for terminal states",
      "        result = self.check_winner()",
      "        if result == self.ai_symbol:",
      "            return 10 - depth, None  # AI wins (higher score for quicker wins)",
      "        elif result == self.player_symbol:",
      "            return depth - 10, None  # Human wins (lower score for quicker losses)",
      "        elif result == 'Draw':",
      "            return 0, None  # Draw",
      "        empty_cells = self.get_empty_cells()",
      "        if not empty_cells:",
      "            return 0, None  # Draw",
      "        best_move = None",
      "        if is_maximizing:  # AI's turn (maximize)",
      "            best_score = float('-inf')",
      "            for row, col in empty_cells:",
      "                self.board[row][col] = self.ai_symbol",
      "                score, _ = self.minimax(depth + 1, False, alpha, beta)",
      "                self.board[row][col] = ' '",
      "                if score > best_score:",
      "                    best_score = score",
      "                    best_move = (row, col)",
      "                alpha = max(alpha, best_score)",
      "                if beta <= alpha:",
      "                    break",
      "            return best_score, best_move",
      "        else:  # Human's turn (minimize)",
      "            best_score = float('inf')",
      "            for row, col in empty_cells:",
      "                self.board[row][col] = self.player_symbol",
      "                score, _ = self.minimax(depth + 1, True, alpha, beta)",
      "                self.board[row][col] = ' '",
      "                if score < best_score:",
      "                    best_score = score",
      "                    best_move = (row, col)",
      "                beta = min(beta, best_score)",
      "                if beta <= alpha:",
      "                    break",
      "            return best_score, best_move",
      "    ",
      "    def ai_move(self):",
      "        \"\"\"AI makes the best move using Minimax algorithm\"\"\"",
      "        _, (row, col) = self.minimax(0, True)",
      "        if row is not None and col is not None:",
      "            self.make_move(row, col, self.ai_symbol)",
      "            print(f\"AI places {self.ai_symbol} at position ({row}, {col})\")",
      "    ",
      "    def play_game(self):",
      "        \"\"\"Main game loop\"\"\"",
      "        print(\"Welcome to Tic-Tac-Toe!\")",
      "        print(\"You are 'O' and the AI is 'X'\")",
      "        print(\"Enter row and column (0-2) separated by space\")",
      "        print()",
      "        game_over = False",
      "        self.ai_move()",
      "        self.print_board()",
      "        while not game_over:",
      "            try:",
      "                row, col = map(int, input(\"Enter row and column (0-2): \").split())",
      "                if self.make_move(row, col, self.player_symbol):",
      "                    self.print_board()",
      "                    result = self.check_winner()",
      "                    if result:",
      "                        if result == 'Draw':",
      "                            print(\"It's a draw!\")",
      "                        else:",
      "                            print(f\"{result} wins!\")",
      "                        game_over = True",
      "                        break",
      "                    self.ai_move()",
      "                    self.print_board()",
      "                    result = self.check_winner()",
      "                    if result:",
      "                        if result == 'Draw':",
      "                            print(\"It's a draw!\")",
      "                        else:",
      "                            print(f\"{result} wins!\")",
      "                        game_over = True",
      "                else:",
      "                    print(\"Invalid move. Cell already occupied or out of bounds.\")",
      "            except ValueError:",
      "                print(\"Please enter two numbers separated by space.\")",
      "        print(\"Game Over!\")",
      "",
      "if __name__ == '__main__':",
      "    game = TicTacToe()",
      "    game.play_game()"
    ],
    "description": "Full TicTacToe Minimax code from lab06.py"
  },
  "CoinGameAlphaBeta": {
    "prefix": "???coin-game-ab",
    "body": [
      "class CoinGame:",
      "    def __init__(self, coins):",
      "        self.coins = coins",
      "        self.max_score = 0",
      "        self.min_score = 0",
      "    def print_state(self):",
      "        \"\"\"Print the current state of the game\"\"\"",
      "        print(f\"Remaining Coins: {self.coins}\")",
      "        print(f\"Current Scores - Max: {self.max_score}, Min: {self.min_score}\")",
      "    def is_game_over(self):",
      "        \"\"\"Check if the game is over\"\"\"",
      "        return len(self.coins) == 0",
      "    def alpha_beta_pruning(self, depth, alpha, beta, is_maximizing, start, end):",
      "        \"\"\"",
      "        Alpha-Beta Pruning algorithm for the coin game",
      "        Args:",
      "            depth: Current depth in the search tree",
      "            alpha: Alpha value",
      "            beta: Beta value",
      "            is_maximizing: Whether the current player is maximizing",
      "            start: Start index of the remaining coins",
      "            end: End index of the remaining coins",
      "        Returns:",
      "            The optimal value for the current player",
      "        \"\"\"",
      "        if start > end:",
      "            return 0",
      "        if is_maximizing:",
      "            best_value = float('-inf')",
      "            left_val = self.coins[start] + self.alpha_beta_pruning(depth + 1, alpha, beta, False, start + 1, end)",
      "            best_value = max(best_value, left_val)",
      "            alpha = max(alpha, best_value)",
      "            if beta <= alpha:",
      "                return best_value",
      "            right_val = self.coins[end] + self.alpha_beta_pruning(depth + 1, alpha, beta, False, start, end - 1)",
      "            best_value = max(best_value, right_val)",
      "            alpha = max(alpha, best_value)",
      "            return best_value",
      "        else:",
      "            best_value = float('inf')",
      "            left_val = self.alpha_beta_pruning(depth + 1, alpha, beta, True, start + 1, end)",
      "            best_value = min(best_value, left_val)",
      "            beta = min(beta, best_value)",
      "            if beta <= alpha:",
      "                return best_value",
      "            right_val = self.alpha_beta_pruning(depth + 1, alpha, beta, True, start, end - 1)",
      "            best_value = min(best_value, right_val)",
      "            beta = min(beta, best_value)",
      "            return best_value",
      "    def get_optimal_move(self):",
      "        \"\"\"Get the optimal move (left or right) for Max using Alpha-Beta Pruning\"\"\"",
      "        if not self.coins:",
      "            return None",
      "        start = 0",
      "        end = len(self.coins) - 1",
      "        left_val = self.coins[start] + self.alpha_beta_pruning(0, float('-inf'), float('inf'), False, start + 1, end)",
      "        right_val = self.coins[end] + self.alpha_beta_pruning(0, float('-inf'), float('inf'), False, start, end - 1)",
      "        if left_val >= right_val:",
      "            return \"left\"",
      "        else:",
      "            return \"right\"",
      "    def min_choose(self):",
      "        \"\"\"Min player chooses the coin that minimizes Max's potential gain\"\"\"",
      "        if not self.coins:",
      "            return None",
      "        if self.coins[0] <= self.coins[-1]:",
      "            return \"left\"",
      "        else:",
      "            return \"right\"",
      "    def play_game(self):",
      "        \"\"\"Main game loop\"\"\"",
      "        print(\"Coin Game with Alpha-Beta Pruning\")",
      "        print(f\"Initial Coins: {self.coins}\")",
      "        turn = \"Max\"",
      "        while not self.is_game_over():",
      "            if turn == \"Max\":",
      "                move = self.get_optimal_move()",
      "                if move == \"left\":",
      "                    coin = self.coins.pop(0)",
      "                    self.max_score += coin",
      "                    print(f\"Max picks {coin} from left, Remaining Coins: {self.coins}\")",
      "                else:",
      "                    coin = self.coins.pop()",
      "                    self.max_score += coin",
      "                    print(f\"Max picks {coin} from right, Remaining Coins: {self.coins}\")",
      "                turn = \"Min\"",
      "            else:",
      "                move = self.min_choose()",
      "                if move == \"left\":",
      "                    coin = self.coins.pop(0)",
      "                    self.min_score += coin",
      "                    print(f\"Min picks {coin} from left, Remaining Coins: {self.coins}\")",
      "                else:",
      "                    coin = self.coins.pop()",
      "                    self.min_score += coin",
      "                    print(f\"Min picks {coin} from right, Remaining Coins: {self.coins}\")",
      "                turn = \"Max\"",
      "        print(\"\nFinal Scores - Max: {}, Min: {}\".format(self.max_score, self.min_score))",
      "        if self.max_score > self.min_score:",
      "            print(\"Winner: Max\")",
      "        elif self.max_score < self.min_score:",
      "            print(\"Winner: Min\")",
      "        else:",
      "            print(\"It's a tie!\")",
      "",
      "if __name__ == '__main__':",
      "    coins = [3, 9, 1, 2, 7, 5]",
      "    game = CoinGame(coins)",
      "    game.play_game()"
    ],
    "description": "Full Coin Game Alpha-Beta code from lab06.py"
  },
  "LetterWordGameMinimax": {
    "prefix": "???letter-word-minimax",
    "body": [
      "import random",
      "",
      "class LetterWordGame:",
      "    def __init__(self, letters, word_list):",
      "        \"\"\"",
      "        Initialize the Letter-Word Game.",
      "        Args:",
      "            letters: List of available letters to pick from",
      "            word_list: List of valid words",
      "        \"\"\"",
      "        self.letters = letters",
      "        self.word_list = word_list",
      "        self.max_letters = []  # Letters selected by Max",
      "        self.min_letters = []  # Letters selected by Min",
      "        self.current_word = \"\"  # Word being formed",
      "    def is_valid_word(self, word):",
      "        \"\"\"Check if a word is valid (exists in word_list)\"\"\"",
      "        return word.lower() in [w.lower() for w in self.word_list]",
      "    def calculate_score(self, word):",
      "        \"\"\"",
      "        Calculate the score for a word.",
      "        Longer words get higher scores, invalid words get penalties.",
      "        \"\"\"",
      "        if not word:",
      "            return 0",
      "        if self.is_valid_word(word):",
      "            return len(word) * 2  # Reward for valid words",
      "        else:",
      "            return -len(word)  # Penalty for invalid words",
      "    def available_moves(self, letters_pool):",
      "        \"\"\"Get list of available letters to choose from\"\"\"",
      "        return letters_pool.copy()",
      "    def minimax(self, depth, letters_pool, current_word, is_maximizing, alpha=float('-inf'), beta=float('inf')):",
      "        \"\"\"",
      "        MiniMax algorithm with Alpha-Beta pruning",
      "        Args:",
      "            depth: Current depth in the search tree",
      "            letters_pool: Letters still available to choose from",
      "            current_word: Word formed so far",
      "            is_maximizing: Whether current player is maximizing",
      "            alpha, beta: Alpha-Beta pruning parameters",
      "        Returns:",
      "            The best score and the letter to choose",
      "        \"\"\"",
      "        if depth == 0 or not letters_pool:",
      "            return self.calculate_score(current_word), None",
      "        available_letters = self.available_moves(letters_pool)",
      "        if is_maximizing:",
      "            best_score = float('-inf')",
      "            best_letter = None",
      "            for letter in available_letters:",
      "                new_letters_pool = letters_pool.copy()",
      "                new_letters_pool.remove(letter)",
      "                new_word = current_word + letter",
      "                score, _ = self.minimax(depth - 1, new_letters_pool, new_word, False, alpha, beta)",
      "                if score > best_score:",
      "                    best_score = score",
      "                    best_letter = letter",
      "                alpha = max(alpha, best_score)",
      "                if beta <= alpha:",
      "                    break",
      "            return best_score, best_letter",
      "        else:",
      "            best_score = float('inf')",
      "            best_letter = None",
      "            for letter in available_letters:",
      "                new_letters_pool = letters_pool.copy()",
      "                new_letters_pool.remove(letter)",
      "                new_word = current_word + letter",
      "                score, _ = self.minimax(depth - 1, new_letters_pool, new_word, True, alpha, beta)",
      "                if score < best_score:",
      "                    best_score = score",
      "                    best_letter = letter",
      "                beta = min(beta, best_score)",
      "                if beta <= alpha:",
      "                    break",
      "            return best_score, best_letter",
      "    def play_game(self, max_depth=3):",
      "        \"\"\"",
      "        Main game loop.",
      "        Max_depth controls the depth of the minimax search (and thus difficulty).",
      "        \"\"\"",
      "        print(\"Letter-Word Game with MiniMax Algorithm\")",
      "        print(f\"Available Letters: {self.letters}\")",
      "        print(f\"Goal: Form the longest valid word by taking turns picking letters\")",
      "        print(\"Invalid words will get penalties\")",
      "        print()",
      "        letters_pool = self.letters.copy()",
      "        current_player = \"Max\"",
      "        while letters_pool:",
      "            print(f\"\nCurrent word: {self.current_word}\")",
      "            print(f\"Available letters: {letters_pool}\")",
      "            if current_player == \"Max\":",
      "                print(\"Max's turn...\")",
      "                search_depth = min(max_depth, len(letters_pool))",
      "                _, best_letter = self.minimax(search_depth, letters_pool, self.current_word, True)",
      "                if best_letter:",
      "                    letters_pool.remove(best_letter)",
      "                    self.current_word += best_letter",
      "                    self.max_letters.append(best_letter)",
      "                    print(f\"Max chooses letter: {best_letter}\")",
      "                current_player = \"Min\"",
      "            else:",
      "                print(\"Min's turn...\")",
      "                search_depth = min(max_depth, len(letters_pool))",
      "                _, best_letter = self.minimax(search_depth, letters_pool, self.current_word, False)",
      "                if best_letter:",
      "                    letters_pool.remove(best_letter)",
      "                    self.current_word += best_letter",
      "                    self.min_letters.append(best_letter)",
      "                    print(f\"Min chooses letter: {best_letter}\")",
      "                current_player = \"Max\"",
      "        print(\"\nGame Over!\")",
      "        print(f\"Final word: {self.current_word}\")",
      "        score = self.calculate_score(self.current_word)",
      "        if self.is_valid_word(self.current_word):",
      "            print(f\"The word '{self.current_word}' is valid!\")",
      "            print(f\"Score: {score}\")",
      "        else:",
      "            print(f\"The word '{self.current_word}' is NOT valid!\")",
      "            print(f\"Score: {score}\")",
      "",
      "if __name__ == '__main__':",
      "    letters = ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n']",
      "    word_list = ['apple', 'cat', 'application', 'app', 'tap', 'plan', 'alpha', 'ion', 'note', 'plant']",
      "    game = LetterWordGame(letters, word_list)",
      "    game.play_game(max_depth=3)"
    ],
    "description": "Full Letter-Word Game Minimax code from lab06.py"
  }
}