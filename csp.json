{
  "SimpleCPSAT": {
    "prefix": "simple-cpsat",
    "body": [
      "from ortools.sat.python import cp_model",
      "",
      "def simple_sat_program():",
      "    \"\"\"Minimal CP-SAT example to showcase calling the solver.\"\"\"",
      "    model = cp_model.CpModel()",
      "    num_vals = 3",
      "",
      "    # Create variables",
      "    x = model.NewIntVar(0, num_vals - 1, \"x\")",
      "    y = model.NewIntVar(0, num_vals - 1, \"y\")",
      "    z = model.NewIntVar(0, num_vals - 1, \"z\")",
      "",
      "    # Add constraints",
      "    model.Add(x != y)",
      "",
      "    # Solve",
      "    solver = cp_model.CpSolver()",
      "    status = solver.Solve(model)",
      "",
      "    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:",
      "        print(f\"x = {solver.Value(x)}\")",
      "        print(f\"y = {solver.Value(y)}\")",
      "        print(f\"z = {solver.Value(z)}\")",
      "    else:",
      "        print(\"No solution found.\")"
    ],
    "description": "Simple CP-SAT example with basic variables and constraints"
  },
  "CPSATAllSolutions": {
    "prefix": "cpsat-all-solutions",
    "body": [
      "from ortools.sat.python import cp_model",
      "",
      "class VarArraySolutionPrinter(cp_model.CpSolverSolutionCallback):",
      "    \"\"\"Print intermediate solutions.\"\"\"",
      "    def __init__(self, variables: list[cp_model.IntVar]):",
      "        cp_model.CpSolverSolutionCallback.__init__(self)",
      "        self.__variables = variables",
      "        self.__solution_count = 0",
      "",
      "    def on_solution_callback(self) -> None:",
      "        self.__solution_count += 1",
      "        for v in self.__variables:",
      "            print(f\"{v}={self.value(v)}\", end=\" \")",
      "        print()",
      "",
      "    @property",
      "    def solution_count(self) -> int:",
      "        return self.__solution_count",
      "",
      "def search_for_all_solutions_sample_sat():",
      "    \"\"\"Showcases calling the solver to search for all solutions.\"\"\"",
      "    # Creates the model.",
      "    model = cp_model.CpModel()",
      "",
      "    # Creates the variables.",
      "    num_vals = 3",
      "    x = model.new_int_var(0, num_vals - 1, \"x\")",
      "    y = model.new_int_var(0, num_vals - 1, \"y\")",
      "    z = model.new_int_var(0, num_vals - 1, \"z\")",
      "",
      "    # Create the constraints.",
      "    model.add(x != y)",
      "",
      "    # Create a solver and solve.",
      "    solver = cp_model.CpSolver()",
      "    solution_printer = VarArraySolutionPrinter([x, y, z])",
      "",
      "    # Enumerate all solutions.",
      "    solver.parameters.enumerate_all_solutions = True",
      "",
      "    # Solve.",
      "    status = solver.solve(model, solution_printer)",
      "    print(f\"Status = {solver.status_name(status)}\")",
      "    print(f\"Number of solutions found: {solution_printer.solution_count}\")"
    ],
    "description": "CP-SAT example showing how to find all solutions using a callback"
  },
  "LinearOptimization": {
    "prefix": "cpsat-linear-optimization",
    "body": [
      "from ortools.sat.python import cp_model",
      "",
      "def linear_optimization_example() -> None:",
      "    \"\"\"Example showing how to use CP-SAT for linear optimization.\"\"\"",
      "    # Creates the model.",
      "    model = cp_model.CpModel()",
      "",
      "    # Creates the variables.",
      "    var_upper_bound = max(50, 45, 37)",
      "    x = model.new_int_var(0, var_upper_bound, \"x\")",
      "    y = model.new_int_var(0, var_upper_bound, \"y\")",
      "    z = model.new_int_var(0, var_upper_bound, \"z\")",
      "",
      "    # Creates the constraints.",
      "    model.add(2 * x + 7 * y + 3 * z <= 50)",
      "    model.add(3 * x - 5 * y + 7 * z <= 45)",
      "    model.add(5 * x + 2 * y - 6 * z <= 37)",
      "",
      "    # Defining the Objective function",
      "    model.maximize(2 * x + 2 * y + 3 * z)",
      "",
      "    # Creates a solver and solves the model.",
      "    solver = cp_model.CpSolver()",
      "    status = solver.solve(model)",
      "",
      "    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:",
      "        print(f\"Maximum of objective function: {solver.objective_value}\\n\")",
      "        print(f\"x = {solver.value(x)}\")",
      "        print(f\"y = {solver.value(y)}\")",
      "        print(f\"z = {solver.value(z)}\")",
      "    else:",
      "        print(\"No solution found.\")",
      "",
      "    # Statistics.",
      "    print(\"\\nStatistics\")",
      "    print(f\" status : {solver.status_name(status)}\")",
      "    print(f\" conflicts: {solver.num_conflicts}\")",
      "    print(f\" branches : {solver.num_branches}\")",
      "    print(f\" wall time: {solver.wall_time} s\")"
    ],
    "description": "CP-SAT example for linear optimization with constraints and objective function"
  },
  "NQueensProblem": {
    "prefix": "cpsat-nqueens",
    "body": [
      "from ortools.sat.python import cp_model",
      "",
      "def solve_nqueens(board_size=8):",
      "    \"\"\"Solve the N-Queens problem using CP-SAT.\"\"\"",
      "    # Declare the model",
      "    model = cp_model.CpModel()",
      "",
      "    # There are `board_size` number of variables, one for a queen in each column",
      "    # of the board. The value of each variable is the row that the queen is in.",
      "    queens = [model.new_int_var(0, board_size - 1, f\"x_{i}\") for i in range(board_size)]",
      "",
      "    # All rows must be different.",
      "    model.add_all_different(queens)",
      "",
      "    # No two queens can be on the same diagonal.",
      "    # For / diagonals",
      "    model.add_all_different(queens[i] + i for i in range(board_size))",
      "    # For \\ diagonals",
      "    model.add_all_different(queens[i] - i for i in range(board_size))",
      "",
      "    # Create a solution printer",
      "    class NQueenSolutionPrinter(cp_model.CpSolverSolutionCallback):",
      "        def __init__(self, variables):",
      "            cp_model.CpSolverSolutionCallback.__init__(self)",
      "            self.__variables = variables",
      "            self.__solution_count = 0",
      "",
      "        def on_solution_callback(self):",
      "            self.__solution_count += 1",
      "            solution = [self.value(var) for var in self.__variables]",
      "",
      "            # Print the board",
      "            for i in range(len(solution)):",
      "                line = \"\"",
      "                for j in range(len(solution)):",
      "                    if solution[j] == i:",
      "                        line += \"Q \"",
      "                    else:",
      "                        line += \"_ \"",
      "                print(line)",
      "            print()",
      "",
      "            # Limit to printing just a few solutions",
      "            if self.__solution_count >= 10:",
      "                print(f\"...{self.__solution_count - 10} other solutions displayed...\")",
      "                self.StopSearch()",
      "",
      "        @property",
      "        def solution_count(self):",
      "            return self.__solution_count",
      "",
      "    # Solve the model",
      "    solver = cp_model.CpSolver()",
      "    solution_printer = NQueenSolutionPrinter(queens)",
      "    solver.parameters.enumerate_all_solutions = True",
      "    solver.solve(model, solution_printer)",
      "",
      "    print(f\"Solutions found: {solution_printer.solution_count}\")"
    ],
    "description": "CP-SAT implementation of the N-Queens problem with solution visualization"
  },
  "DiagonalPathFinder": {
    "prefix": "cpsat-path-finder",
    "body": [
      "from ortools.sat.python import cp_model",
      "import math",
      "",
      "def pathSolver(grid, start, target):",
      "    \"\"\"Find a diagonal path from start to target on a grid.\"\"\"",
      "    rows = len(grid)",
      "    cols = len(grid[0])",
      "",
      "    max_path_length = rows * cols",
      "",
      "    model = cp_model.CpModel()",
      "",
      "    path_vars = {}",
      "    for i in range(rows):",
      "        for j in range(cols):",
      "            path_vars[(i, j)] = model.NewBoolVar(f'path_{i}_{j}')",
      "",
      "    order_vars = {}",
      "    for i in range(rows):",
      "        for j in range(cols):",
      "            order_vars[(i, j)] = model.NewIntVar(0, max_path_length, f'order_{i}_{j}')",
      "",
      "    model.Add(path_vars[start] == 1)",
      "    model.Add(path_vars[target] == 1)",
      "",
      "    model.Add(order_vars[start] == 0)",
      "",
      "    for i in range(rows):",
      "        for j in range(cols):",
      "            if grid[i][j] == 1:",
      "                model.Add(path_vars[(i, j)] == 0)",
      "",
      "    def isDiagonal(p1, p2):",
      "        return abs(p1[0] - p2[0]) == 1 and abs(p1[1] - p2[1]) == 1",
      "",
      "    for i in range(rows):",
      "        for j in range(cols):",
      "            if (i, j) != start and (i, j) != target and grid[i][j] == 0:",
      "                neighbors = []",
      "                for ni in range(max(0, i-1), min(rows, i+2)):",
      "                    for nj in range(max(0, j-1), min(cols, j+2)):",
      "                        if isDiagonal((i, j), (ni, nj)):",
      "                            neighbors.append(path_vars[(ni, nj)])",
      "",
      "                model.Add(sum(neighbors) == 2).OnlyEnforceIf(path_vars[(i, j)])",
      "",
      "                model.Add(order_vars[(i, j)] == max_path_length).OnlyEnforceIf(path_vars[(i, j)].Not())",
      "",
      "    def addEndpointConstraint(cell):",
      "        neighbors = []",
      "        for ni in range(max(0, cell[0]-1), min(rows, cell[0]+2)):",
      "            for nj in range(max(0, cell[1]-1), min(cols, cell[1]+2)):",
      "                if isDiagonal(cell, (ni, nj)):",
      "                    neighbors.append(path_vars[(ni, nj)])",
      "        model.Add(sum(neighbors) == 1)",
      "",
      "    addEndpointConstraint(start)",
      "    addEndpointConstraint(target)",
      "",
      "    for i in range(rows):",
      "        for j in range(cols):",
      "            if (i, j) != start and grid[i][j] == 0:",
      "                for ni in range(max(0, i-1), min(rows, i+2)):",
      "                    for nj in range(max(0, j-1), min(cols, j+2)):",
      "                        if isDiagonal((i, j), (ni, nj)):",
      "                            neighbor_in_path = path_vars[(ni, nj)]",
      "                            cell_in_path = path_vars[(i, j)]",
      "",
      "                            if (i, j) != target:",
      "                                b1 = model.NewBoolVar(f'b1_{i}_{j}_{ni}_{nj}')",
      "                                model.Add(order_vars[(i, j)] == order_vars[(ni, nj)] + 1).OnlyEnforceIf(b1)",
      "",
      "                                model.AddImplication(b1, cell_in_path)",
      "                                model.AddImplication(b1, neighbor_in_path)",
      "",
      "                            if (i, j) != start:",
      "                                b2 = model.NewBoolVar(f'b2_{i}_{j}_{ni}_{nj}')",
      "                                model.Add(order_vars[(i, j)] == order_vars[(ni, nj)] - 1).OnlyEnforceIf(b2)",
      "",
      "                                model.AddImplication(b2, cell_in_path)",
      "                                model.AddImplication(b2, neighbor_in_path)",
      "",
      "    for i in range(rows):",
      "        for j in range(cols):",
      "            if (i, j) != target:",
      "                b = model.NewBoolVar(f'b_target_gt_{i}_{j}')",
      "                model.Add(order_vars[target] > order_vars[(i, j)]).OnlyEnforceIf(b)",
      "                model.Add(order_vars[(i, j)] == max_path_length).OnlyEnforceIf(b.Not())",
      "                model.AddImplication(path_vars[(i, j)], b)",
      "",
      "    objective_terms = []",
      "    for i in range(rows):",
      "        for j in range(cols):",
      "            if grid[i][j] == 0:",
      "                objective_terms.append(path_vars[(i, j)] * 141)",
      "",
      "    model.Minimize(sum(objective_terms))",
      "",
      "    solver = cp_model.CpSolver()",
      "    status = solver.Solve(model)",
      "",
      "    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:",
      "        path_cells = []",
      "        for i in range(rows):",
      "            for j in range(cols):",
      "                if solver.Value(path_vars[(i, j)]) == 1:",
      "                    path_cells.append((i, j, solver.Value(order_vars[(i, j)])))",
      "",
      "        path_cells.sort(key=lambda x: x[2])",
      "",
      "        return [(x[0], x[1]) for x in path_cells]",
      "    else:",
      "        return \"No solution found.\"",
      "",
      "# Example usage",
      "grid = [",
      "    [0, 0, 0, 0, 0],",
      "    [0, 0, 0, 0, 0],",
      "    [0, 0, 1, 1, 0],",
      "    [0, 1, 0, 0, 0],",
      "    [0, 0, 0, 0, 0],",
      "]",
      "",
      "start = (1, 1)",
      "target = (4, 4)",
      "",
      "path = pathSolver(grid, start, target)",
      "print(\"Path:\", path)",
      "print(f\"Path length: {len(path)-1} diagonal moves\")",
      "if isinstance(path, list) and len(path) > 1:",
      "    total_distance = sum(math.sqrt(2) for _ in range(len(path)-1))",
      "    print(f\"Total distance: {total_distance:.2f} units\")",
      "else:",
      "    print(\"No path found.\")"
    ],
    "description": "CP-SAT implementation of a diagonal path finder on a grid"
  },
  "IslandBoundaryTracker": {
    "prefix": "cpsat-island-boundary",
    "body": [
      "from ortools.sat.python import cp_model",
      "import numpy as np",
      "",
      "def solve_island_boundary():",
      "    \"\"\"Track the boundary of an island in a grid map.\"\"\"",
      "    # Sample island map (5x5 grid with land and water)",
      "    # 1 represents land, 0 represents water",
      "    island_map = np.array([",
      "        [0, 0, 0, 0, 0],",
      "        [0, 1, 1, 1, 0],",
      "        [0, 1, 1, 1, 0],",
      "        [0, 1, 1, 0, 0],",
      "        [0, 0, 0, 0, 0]",
      "    ])",
      "    rows, cols = island_map.shape",
      "    model = cp_model.CpModel()",
      "",
      "    # 1. Define the constraint model",
      "    # Binary variables for each cell (1 for land, 0 for water)",
      "    # These values come from the input map",
      "    cell = {}",
      "    for i in range(rows):",
      "        for j in range(cols):",
      "            cell[(i, j)] = model.new_int_var(0, 1, f\"cell_{i}_{j}\")",
      "            # Set the value according to the island map",
      "            model.add(cell[(i, j)] == island_map[i, j])",
      "",
      "    # 2. Identify boundary edges",
      "    # A boundary edge is where land meets water",
      "    # Create variables to represent if a cell is on the boundary",
      "    boundary = {}",
      "    for i in range(rows):",
      "        for j in range(cols):",
      "            boundary[(i, j)] = model.new_bool_var(f\"boundary_{i}_{j}\")",
      "",
      "            # A cell is on the boundary if:",
      "            # - It is land (value 1)",
      "            # - At least one of its adjacent cells is water (value 0)",
      "",
      "            # Check if the current cell is land",
      "            is_land = model.new_bool_var(f\"is_land_{i}_{j}\")",
      "            model.add(cell[(i, j)] == 1).OnlyEnforceIf(is_land)",
      "            model.add(cell[(i, j)] == 0).OnlyEnforceIf(is_land.Not())",
      "",
      "            # Check if any adjacent cell is water",
      "            adjacent_water = []",
      "            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:  # 4-connected neighbors",
      "                ni, nj = i + di, j + dj",
      "                if 0 <= ni < rows and 0 <= nj < cols:",
      "                    neighbor_is_water = model.new_bool_var(f\"neighbor_water_{i}_{j}_{ni}_{nj}\")",
      "                    model.add(cell[(ni, nj)] == 0).OnlyEnforceIf(neighbor_is_water)",
      "                    model.add(cell[(ni, nj)] == 1).OnlyEnforceIf(neighbor_is_water.Not())",
      "                    adjacent_water.append(neighbor_is_water)",
      "                else:",
      "                    # Cells on the grid edge with no neighbor are considered adjacent to water",
      "                    adjacent_water.append(model.new_bool_var(f\"edge_water_{i}_{j}_{di}_{dj}\"))",
      "                    model.add(adjacent_water[-1] == 1)  # Always true",
      "",
      "            # A cell is a boundary cell if it's land and has at least one water neighbor",
      "            has_water_neighbor = model.new_bool_var(f\"has_water_neighbor_{i}_{j}\")",
      "            model.add_bool_or([water for water in adjacent_water]).OnlyEnforceIf(has_water_neighbor)",
      "            model.add_bool_and([water.Not() for water in adjacent_water]).OnlyEnforceIf(has_water_neighbor.Not())",
      "",
      "            # Boundary condition: land AND has_water_neighbor",
      "            model.add_bool_and([is_land, has_water_neighbor]).OnlyEnforceIf(boundary[(i, j)])",
      "            model.add_bool_or([is_land.Not(), has_water_neighbor.Not()]).OnlyEnforceIf(boundary[(i, j)].Not())",
      "",
      "    # 3. Find the perimeter (number of boundary cells)",
      "    perimeter = model.new_int_var(0, rows * cols, \"perimeter\")",
      "    model.add(perimeter == sum(boundary.values()))",
      "",
      "    # Objective: Maximize the perimeter to find the largest continuous landmass boundary",
      "    model.maximize(perimeter)",
      "",
      "    # Solve the model",
      "    solver = cp_model.CpSolver()",
      "    status = solver.solve(model)",
      "",
      "    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:",
      "        # Extract the boundary cells",
      "        boundary_cells = []",
      "        boundary_count = 0",
      "",
      "        for i in range(rows):",
      "            for j in range(cols):",
      "                if solver.value(boundary[(i, j)]) == 1:",
      "                    boundary_cells.append((i, j))",
      "                    boundary_count += 1",
      "",
      "        print(f\"Perimeter length: {boundary_count}\")",
      "        print(\"Boundary cells:\")",
      "        for cell in boundary_cells:",
      "            print(f\"  {cell}\")",
      "",
      "        # Visualize the island and its boundary",
      "        visualization = np.full((rows, cols), ' ')",
      "",
      "        # Mark land and water",
      "        for i in range(rows):",
      "            for j in range(cols):",
      "                if island_map[i, j] == 1:",
      "                    visualization[i, j] = '█'  # Land",
      "                else:",
      "                    visualization[i, j] = '~'  # Water",
      "",
      "        # Mark boundary cells",
      "        for i, j in boundary_cells:",
      "            visualization[i, j] = 'B'",
      "",
      "        print(\"\\nVisualization:\")",
      "        for row in visualization:",
      "            print(' '.join(row))",
      "    else:",
      "        print(\"No solution found.\")"
    ],
    "description": "CP-SAT implementation to track island boundaries in a grid map"
  },
  "TSPSolver": {
    "prefix": "cpsat-tsp",
    "body": [
      "from ortools.sat.python import cp_model",
      "import math",
      "import random",
      "import time",
      "",
      "def solve_tsp():",
      "    \"\"\"Solve the Traveling Salesperson Problem using CP-SAT.\"\"\"",
      "    n_cities = 10",
      "",
      "    random.seed(42)",
      "    cities = [(random.randint(0, 100), random.randint(0, 100)) for _ in range(n_cities)]",
      "",
      "    distances = {}",
      "    for i in range(n_cities):",
      "        for j in range(n_cities):",
      "            if i != j:",
      "                distances[(i, j)] = int(math.sqrt((cities[i][0] - cities[j][0])**2 +",
      "                                                  (cities[i][1] - cities[j][1])**2))",
      "",
      "    model = cp_model.CpModel()",
      "",
      "    city_at_pos = {}",
      "    for i in range(n_cities):",
      "        city_at_pos[i] = model.new_int_var(0, n_cities - 1, f'city_at_pos_{i}')",
      "",
      "    pos_of_city = {}",
      "    for i in range(n_cities):",
      "        pos_of_city[i] = model.new_int_var(0, n_cities - 1, f'pos_of_city_{i}')",
      "",
      "    model.add_all_different([city_at_pos[i] for i in range(n_cities)])",
      "",
      "    model.add_all_different([pos_of_city[i] for i in range(n_cities)])",
      "",
      "    for i in range(n_cities):",
      "        for j in range(n_cities):",
      "            b = model.new_bool_var(f'b_link_{i}_{j}')",
      "            model.add(city_at_pos[i] == j).only_enforce_if(b)",
      "            model.add(pos_of_city[j] == i).only_enforce_if(b)",
      "",
      "    obj_terms = []",
      "    for i in range(n_cities):",
      "        for j in range(n_cities):",
      "            for k in range(n_cities):",
      "                if j != k:",
      "                    b = model.new_bool_var(f'b_dist_{i}_{j}_{k}')",
      "                    next_pos = (i + 1) % n_cities",
      "",
      "                    b_j = model.new_bool_var(f'b_j_{i}_{j}')",
      "                    b_k = model.new_bool_var(f'b_k_{next_pos}_{k}')",
      "",
      "                    model.add(city_at_pos[i] == j).only_enforce_if(b_j)",
      "                    model.add(city_at_pos[i] != j).only_enforce_if(b_j.Not())",
      "",
      "                    model.add(city_at_pos[next_pos] == k).only_enforce_if(b_k)",
      "                    model.add(city_at_pos[next_pos] != k).only_enforce_if(b_k.Not())",
      "",
      "                    model.add(b == 0).only_enforce_if(b_j.Not())",
      "                    model.add(b == 0).only_enforce_if(b_k.Not())",
      "                    model.add(b == 1).only_enforce_if([b_j, b_k])",
      "",
      "                    dist_term = model.new_int_var(0, 1000000, f'dist_term_{i}_{j}_{k}')",
      "                    model.add(dist_term == distances[(j, k)]).only_enforce_if(b)",
      "                    model.add(dist_term == 0).only_enforce_if(b.Not())",
      "                    obj_terms.append(dist_term)",
      "",
      "    model.minimize(sum(obj_terms))",
      "",
      "    model.add(pos_of_city[0] == 0)",
      "",
      "    print(\"Solving TSP for\", n_cities, \"cities...\")",
      "    start_time = time.time()",
      "",
      "    solver = cp_model.CpSolver()",
      "    solver.parameters.max_time_in_seconds = 120",
      "",
      "    status = solver.solve(model)",
      "",
      "    solve_time = time.time() - start_time",
      "    print(f\"Solve completed in {solve_time:.2f} seconds.\")",
      "",
      "    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:",
      "        print(\"Solution found!\")",
      "",
      "        tour = []",
      "        for i in range(n_cities):",
      "            tour.append(solver.value(city_at_pos[i]))",
      "",
      "        total_distance = 0",
      "        for i in range(n_cities):",
      "            from_city = tour[i]",
      "            to_city = tour[(i + 1) % n_cities]",
      "            total_distance += distances[(from_city, to_city)]",
      "",
      "        print(\"\\nOptimal tour:\")",
      "        print(\" -> \".join(str(city) for city in tour) + f\" -> {tour[0]}\")",
      "",
      "        print(\"\\nCity coordinates:\")",
      "        for i, (x, y) in enumerate(cities):",
      "            print(f\"City {i}: ({x}, {y})\")",
      "",
      "        print(f\"\\nTotal distance: {total_distance}\")",
      "        print(f\"Objective value: {solver.objective_value}\")",
      "    else:",
      "        print(\"No solution found within the time limit.\")",
      "        print(\"Status:\", solver.StatusName())"
    ],
    "description": "CP-SAT implementation of the Traveling Salesperson Problem (TSP) with optimization"
  }
}